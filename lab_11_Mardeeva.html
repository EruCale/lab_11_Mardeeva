{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "d21dc5ca-8a38-4f0c-b9cb-b3f73b0d3b31",
   "metadata": {},
   "source": [
    "---\n",
    "title: 'Лабораторна робота №11. Об’єктно-орієнтоване програмування. Частина І'\n",
    "description:\n",
    "   Документ зроблено за допомогою [Quarto](https://quarto.org/)\n",
    "author: \"&copy; [<span style='color: blue;'> Мардєєва Діана </span>], 2024\"\n",
    "date: \"02.12.2024\"\n",
    "lang: ukr\n",
    "format:\n",
    "  html:\n",
    "    code-fold: true\n",
    "    toc: true # меню\n",
    "    toc_float: # спливаюче меню  \n",
    "      collapsed: true # авто\n",
    "      number_sections: true\n",
    "jupyter: python3\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5cde6bed-3e5d-43ed-861e-d5371dfdcc80",
   "metadata": {},
   "source": [
    "__Мета:__ _навчитися обробляти рядки за допомогою спеціальних функцій і методів._"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b26f36cf-5e8e-41b1-98d9-bcc76becd88a",
   "metadata": {},
   "source": [
    "## Основи об’єктно-орієнтованого програмування на Python"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4f3e1b9d-ec2e-49ae-86cb-fc8ba3029f84",
   "metadata": {},
   "source": [
    "### Приклад 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b6e2571d-a73f-4e23-8a07-52d851a2a411",
   "metadata": {},
   "source": [
    "В лекції 12 було показано, як розширити можливості 'Stack', визначивши новий клас (тобто підклас), який зберігає усі успадковані риси та додає деякі нові.\n",
    "\n",
    "Ваше завдання – розширити поведінку класу 'Stack' таким чином, щоб клас міг підраховувати всі елементи, що додаються і видаляються (ми припускаємо, що підрахунку видалень достатньо). Використовуйте клас 'Stack', який надано нижче.\n",
    "\n",
    "Дотримуйтесь підказок:\n",
    "\n",
    "- додайте властивість, призначену для підрахунку операцій 'pop', і дайте йому ім’я, що гарантує його приховування;\n",
    "- ініціалізуйте його нулем усередині конструктора;\n",
    "- додайте метод, який повертає поточне значення, надане лічильнику (назвіть його 'get_counter()').\n",
    "- перевірте код"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b95ecd31-7332-4391-9361-a3ab24dd7fa8",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Stack:\n",
    "    def __init__(self):\n",
    "        self.__stk = []\n",
    "\n",
    "    def push(self, val):\n",
    "        self.__stk.append(val)\n",
    "\n",
    "    def pop(self):\n",
    "        val = self.__stk[-1]\n",
    "        del self.__stk[-1]\n",
    "        return val\n",
    "\n",
    "class CountingStack(Stack):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.__count = 0\n",
    "\n",
    "    def get_counter(self):\n",
    "        return self.__count\n",
    "\n",
    "    def pop(self):\n",
    "        val = super().pop()\n",
    "        self.__count += 1\n",
    "        return val\n",
    "\n",
    "stk = CountingStack()\n",
    "for i in range(100):\n",
    "    stk.push(i)\n",
    "    stk.pop()\n",
    "print(stk.get_counter())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02619ec3-2d58-4fd3-a185-3d116619fbe7",
   "metadata": {},
   "outputs": [],
   "source": [
    "100"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86b7f93d-349b-46db-a4ff-ffc2ed070ae6",
   "metadata": {},
   "source": [
    "### Приклад 2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6ccac403-e2e5-408a-b60b-331884b1d6b3",
   "metadata": {},
   "source": [
    "Як Ви вже знаєте, стек – це структура даних, що реалізує модель LIFO (Last In – First Out).\n",
    "\n",
    "Черга -– це модель даних, що характеризується терміном FIFO: First In – Fist Out. Примітка: звичайна черга, відома Вам з магазинів або поштових відділень, працює так само - першим обслуговується покупець, який прийшов першим.\n",
    "\n",
    "Ваше завдання -– реалізувати клас 'Queue' з двома основними операціями:\n",
    "\n",
    "- 'put(element)', яка поміщає елемент на кінець черги;\n",
    "- 'get()', яка бере елемент із початку черги і повертає його як результат (черга не може бути порожньою для успішного виконання).\n",
    "Дотримуйтесь підказок:\n",
    "\n",
    "- використовуйте список як сховище (як і у випадку зі стеком);\n",
    "- 'put()' повинен додавати елементи на початок списку, а get() повинен видаляти елементи з кінця списку;\n",
    "- визначте новий виняток із ім’ям 'QueueError' (виберіть виняток для його створення) та викличте його, коли 'get()' спробує працювати з порожнім списком.\n",
    "Протестуйте код, використовуючи надані нами дані."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3f0d927-761b-4182-abc5-379e6417eb66",
   "metadata": {},
   "outputs": [],
   "source": [
    "class QueueError(Exception):\n",
    "    pass\n",
    "\n",
    "class Queue:\n",
    "    def __init__(self):\n",
    "        self.__queue = []\n",
    "\n",
    "    def put(self, element):\n",
    "        self.__queue.insert(0, element)\n",
    "\n",
    "    def get(self):\n",
    "        if not self.__queue:\n",
    "            raise QueueError(\"Черга порожня!\")\n",
    "        return self.__queue.pop()\n",
    "\n",
    "try:\n",
    "    q = Queue()\n",
    "    q.put(1)\n",
    "    q.put(\"dog\")\n",
    "    q.put(False)\n",
    "\n",
    "    print(q.get())\n",
    "    print(q.get())\n",
    "    print(q.get())\n",
    "\n",
    "    print(q.get())\n",
    "except QueueError as e:\n",
    "    print(f\"QueueError: {e}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c7c3c221-99b6-4b70-a393-4707f395024b",
   "metadata": {},
   "outputs": [],
   "source": [
    "## Очікуваний результат"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "642d6113-285f-450f-bcd4-756cfa66e811",
   "metadata": {},
   "source": [
    "'1'\n",
    "'dog'\n",
    "'False'\n",
    "'Queue error'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "353b2ffe-7699-4819-a707-d1f56a5997a6",
   "metadata": {},
   "outputs": [],
   "source": [
    "1\n",
    "dog\n",
    "False\n",
    "QueueError: Черга порожня!"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fc280f2a-db08-4a00-955f-f08cc05be21e",
   "metadata": {},
   "source": [
    "### Завдання 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e623bb61-17c5-41cf-bd28-791e0fbcd6c1",
   "metadata": {},
   "source": [
    "Ваше завдання –- трохи розширити можливості класу 'Queue' (див. попередній приклад). Нам потрібен метод без параметрів, який повертає 'True', якщо черга порожня, і 'False' інакше.\n",
    "\n",
    "Доповніть код, який надано нижче. Запустіть його, щоб перевірити, чи дає він результат, аналогічний нашому."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "87eb5bcd-5714-41bb-9bfe-cff13b1b4e93",
   "metadata": {},
   "outputs": [],
   "source": [
    "class QueueError(Exception):\n",
    "    pass\n",
    "\n",
    "class Queue:\n",
    "    def __init__(self):\n",
    "        self.__queue = []\n",
    "\n",
    "    def put(self, element):\n",
    "        self.__queue.insert(0, element)\n",
    "\n",
    "    def get(self):\n",
    "        if not self.__queue:\n",
    "            raise QueueError(\"Черга порожня!\")\n",
    "        return self.__queue.pop()\n",
    "\n",
    "    def isempty(self):\n",
    "        return len(self.__queue) == 0\n",
    "\n",
    "class SuperQueue(Queue):\n",
    "    pass\n",
    "\n",
    "que = SuperQueue()\n",
    "que.put(1)\n",
    "que.put(\"dog\")\n",
    "que.put(False)\n",
    "\n",
    "for i in range(4):\n",
    "    if not que.isempty():\n",
    "        print(que.get())\n",
    "    else:\n",
    "        print(\"Черга порожня\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dcbfae06-461d-456a-89bd-9d47d54394ef",
   "metadata": {},
   "outputs": [],
   "source": [
    "1\n",
    "dog\n",
    "False\n",
    "Queue empty"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ae5400c-0338-4964-8a83-30cf50099171",
   "metadata": {},
   "source": [
    "## Контрольні запитання"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "031f53e6-a777-4d33-afe1-95a67ca0d3cc",
   "metadata": {},
   "source": [
    "1. У наступному оголошенні чогось не вистачає – чого?\n",
    "\n",
    "class Snakes\n",
    "    def init():\n",
    "        self.sound = 'Sssssss'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f6fc4ecb-9210-4748-89c5-066525b51c4e",
   "metadata": {},
   "outputs": [],
   "source": [
    "У оголошенні не вистачає двох речей:\n",
    "\n",
    "1. Ім'я методу __init__. Це спеціальний метод ініціалізації класу в Python.\n",
    "\n",
    "2. Аргумент self у методі __init__.\n",
    "\n",
    "Ось правильна версія:\n",
    "class Snakes:\n",
    "    def __init__(self):\n",
    "        self.sound = 'Sssssss'\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2b5fcc4-fd40-410d-aef2-1ed4cac8e689",
   "metadata": {},
   "source": [
    "2. Припускаючи, що існує клас з ім’ям 'Snake', напишіть перший рядок оголошення класу Python, вказавши, що новий клас насправді є підкласом 'Snake'."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d34f9467-c656-4433-8afd-52bf51a0aa9a",
   "metadata": {},
   "outputs": [],
   "source": [
    "class NewClass(Snake):"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c51ebb4e-482d-48c3-ae30-265f5a30421d",
   "metadata": {},
   "source": [
    "3. Змініть код, щоб гарантувати, що властивість 'venomous' є приватною.\n",
    "\n",
    "class Snakes:\n",
    "    def __init__(self):\n",
    "        self.sound = 'Sssssss'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f0f44d4a-54b5-4c09-9e9b-b18d270367c2",
   "metadata": {},
   "outputs": [],
   "source": [
    "Щоб зробити властивість venomous приватною, потрібно додати два підкреслення перед ім'ям властивості.\n",
    "class Snakes:\n",
    "    def __init__(self):\n",
    "        self.__venomous = True"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e1ff33b0-7948-4711-b1cb-476bfc614221",
   "metadata": {},
   "source": [
    "## References"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "71bd200f-be9c-4ad5-935d-56a2d6156e3e",
   "metadata": {},
   "source": [
    "1. Лекції \n",
    "2. Методичні вказівки\n",
    "3. https://git-scm.com/book/en/v2\n",
    "4. https://docs.python.org/3/library/index.html"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
